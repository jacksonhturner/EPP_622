# Assignment 3: Which Assember is better (Flye or SmartDeNovo)?

The objective of this assignment is to compare two assemblers, Flye and SmartDeNovo, using a set of nanopore dogwood chromosome 4 reads as an input. Different assemblers work better for different data, so it's important to review them before performing high-throughput assemblies. 

## Step 1: Loading in Data (and LongQC if it works)

First, create a directory to deposit the raw data.
```
mkdir 1_raw_data
cd 1_raw_data
```

Load in your data for this assignment by creating a soft link to the nanopore dogwood chromosome 4 reads. The path for these reads exists within the pickett_shared directory within this class's raw data. 

```
ln -s /pickett_shared/teaching/EPP622_Fall2022/raw_data/citrus_test2/microcitrus_australasica_nanopore.4.fastq .
```

LongQC goes here. At the moment it doesn't work for nanopore reads, but if you want to QC PacBio or any other read type you can!

## Step 2: Perform Assembly With Flye

Create a new directory and navigate to it.
```
cd ..
mkdir 2_flye_assembly
cd 2_flye_assembly
```

This step utilizes Flye, a long-read assembly algorithm that builds repeat graphs using arbitrary, unknown repeat graphs [1]. Because this assembly algorithm is not native to the server, it will need to be installed. Since flye can be found in bioconda, it will be easiest to install using conda.

Install flye by creating a new conda environment and using bioconda to install the Flye package.
```
conda create -n flye
conda activate flye
conda install -c bioconda flye
```

Now that Flye is installed, double check the version number. 

```
conda list flye
```

Due to some quirk of my personal miniconda3, the following commands installed Flye version 2.8.1.

Next, perform the assembly using Flye, referencing its github (https://github.com/fenderglass/Flye) for whatever specifications needed for the data. Because I've installed Flye version 2.8.1, the assembler automatically scaffolds the assembly without a flag. This command lists using 10 threads, but use however many is appropriate for your computational needs and availability. This will take a few minutes, so feel free to run this in screen. Otherwise, now might be a good oportunity to make yourself some hot tea or do something else to enjoy yourself :)

```
flye --nano-raw microcitrus_australasica_nanopore.4.fastq --out-dir flye_assembly --threads 10
conda deactivate
```

The completed assembly can be found within the flye_assembly directory generated by the previous command. The completed assembly object is ```assembly.fasta``` which will be referenced by future commands.

Once the assembly is finished, it is important to calculate statistics of its contigs and scaffolds that can diagnose its quality. Characteristics like scaffold/contig total, N50, L50, and max length can be used to compare assemblies to, in the case of this assignment, determine the best assembler for a given set of reads. BBMap's stats.sh script will be used to generate these statistics.

Find sequencing statistics of Flye's assembly with BBMap and view them with less.

```
cd flye_assembly
/sphinx_local/software/bbmap/stats.sh -Xmx20g in=flye_assembly/assembly.fasta > assembly_stats.txt
less assembly_stats.txt
```
This file displays the following output. These results will be discussed at the end of this document to compare the Flye assembly with the SmartDeNovo assembly for this assignment.

```
Main genome scaffold total:             639
Main genome contig total:               644
Main genome scaffold sequence total:    35.366 MB
Main genome contig sequence total:      35.365 MB       0.001% gap
Main genome scaffold N/L50:             24/271.267 KB
Main genome contig N/L50:               26/270.297 KB
Main genome scaffold N/L90:             201/23.652 KB
Main genome contig N/L90:               206/23.615 KB
Max scaffold length:                    3.337 MB
Max contig length:                      3.337 MB
Number of scaffolds > 50 KB:            129
% main genome in scaffolds > 50 KB:     83.10%
```

## Step 3: Running BUSCO for the Flye Assembly

BUSCO [2] is a software package designed to create human readable metrics used to evaluate assemblies using single-copy genes. Using it alongside BBMap will allow for a more comprehensive comparison of asseblies than either could provide alone. Let's do it!

Create a directory for BUSCO and navigate to it.

```
cd ../../
mkdir 3_flye_busco
cd 3_flye_busco
```

BUSCO, like Flye, can be downloaded via conda. The following command will create a new environment for BUSCO while installing it at the same time.

```
conda create -n busco -c conda-forge -c bioconda busco=5.3.2
conda activate busco
```

Now that a conda environment has been created and activated for BUCSO, it should be run to provide more information for each assembly. The -m flag describes what time of assembly to analyze, -c determines the number of cores dedicated to this job, and -l describes the type of database of orthologs to reference when analyzing each read. Embryophyta is our database of choice, as it contains orthologs of plants.

Run BUSCO, navigate to the directory it creates, and view the output with less.

```
busco -i ../2_flye_assembly/flye_assembly/assembly.fasta -m genome -l embryophyta -c 2 --out flye_assembly.BUSCO
conda deactivate
cd flye_assembly.BUSCO
less short_summary.specific.embryophyta_odb10.flye_assembly.BUSCO.txt
```

The following output is displayed in the .txt file generated by BUSCO. The values within are specific to BUSCO and can be compared with other BUSCO runs of different assemblies to evaluate their quality. Like the statistics created with BBMap, these results will be discussed at the end of this document.

        --------------------------------------------------
        |Results from dataset embryophyta_odb10           |
        --------------------------------------------------
        |C:10.0%[S:9.3%,D:0.7%],F:1.4%,M:88.6%,n:1614     |
        |161    Complete BUSCOs (C)                       |
        |150    Complete and single-copy BUSCOs (S)       |
        |11     Complete and duplicated BUSCOs (D)        |
        |23     Fragmented BUSCOs (F)                     |
        |1430   Missing BUSCOs (M)                        |
        |1614   Total BUSCO groups searched               |
        --------------------------------------------------

## Step 4: Generate SmartDeNovo Assembly

SmartDeNovo [3] is an assembler for long reads like Flye, but it's designed to work well with raw reads that aren't that great. Time to put it to the test!

Create a new directory for SmartDeNovo and navigate to it.

```
cd ../..
mkdir 4_smartdenovo_assembly
cd 4_smartdenovo_assembly
```

The perl script needed to run SmartDeNovo is already on the server, yay! Using it is also straightforward, with the somewhat necessary flag being the number of cores used. Otherwise, there are no other arguments needed to run it.

Run SmartDeNovo on our data.

```
/pickett_shared/software/smartdenovo/smartdenovo.pl -c 5 ../1_raw_data/microcitrus_australasica_nanopore.4.fastq > microcitrus_australasica.fasta
```

The assembly file generated by SmartDeNovo is ```microcitrus_australasica.dmo.cns``` which will be used to generate statistics used to compare it with Flye's assembly.

Next, run BBMap to obtain some assembly statistics like for Flye and view them with less.

```
/sphinx_local/software/bbmap/stats.sh -Xmx20g in=microcitrus_australasica.dmo.cns > microcitrus_australasica_stats.txt
less microcitrus_australasica_stats.txt
```

Like for Flye, this stats file for SmartDeNovo's assembly contains sequence statistics used to compare it with Flye's assembly. More on this at the end.

```
Main genome scaffold total:             149
Main genome contig total:               149
Main genome scaffold sequence total:    27.007 MB
Main genome contig sequence total:      27.007 MB       0.000% gap
Main genome scaffold N/L50:             10/461.296 KB
Main genome contig N/L50:               10/461.296 KB
Main genome scaffold N/L90:             78/59.325 KB
Main genome contig N/L90:               78/59.325 KB
Max scaffold length:                    2.459 MB
Max contig length:                      2.459 MB
Number of scaffolds > 50 KB:            96
% main genome in scaffolds > 50 KB:     93.62%
```

## Step 5: Running BUSCO for the SmartDeNovo Assembly

Create a new directory for BUSCO and navigate to it. Then, run BUSCO on the SmartDeNovo assembly like for Flye and view the file with less.

```
cd ..
mkdir 5_smartdenovo_busco
cd 5_smartdenovo_busco
conda activate busco
busco -i ../4_smartdenovo_assembly/microcitrus_australasica.dmo.cns -m genome -l embryophyta -c 2 --out SDN_assembly.BUSCO
conda deactivate
cd SDN_assembly.BUSCO
less short_summary.specific.embryophyta_odb10.SDN_assembly.BUSCO.txt
```
The following statistics were generated by BUSCO for SmartDeNovo's assembly.

        --------------------------------------------------
        |Results from dataset embryophyta_odb10           |
        --------------------------------------------------
        |C:9.5%[S:9.3%,D:0.2%],F:1.0%,M:89.5%,n:1614      |
        |154    Complete BUSCOs (C)                       |
        |150    Complete and single-copy BUSCOs (S)       |
        |4      Complete and duplicated BUSCOs (D)        |
        |16     Fragmented BUSCOs (F)                     |
        |1444   Missing BUSCOs (M)                        |
        |1614   Total BUSCO groups searched               |
        --------------------------------------------------
        
## Step 6: Comparing Assemblies

Compare assemblies. Describe metrics used by BBMap and BUSCO. Determine which assembler is best.

## References

1. Kolmogorov, M., Yuan, J., Lin, Y. et al. Assembly of long, error-prone reads using repeat graphs. Nat Biotechnol 37, 540–546 (2019). https://doi.org/10.1038/s41587-019-0072-8

2. Felipe A. Simão, Robert M. Waterhouse, Panagiotis Ioannidis, Evgenia V. Kriventseva, Evgeny M. Zdobnov, BUSCO: assessing genome assembly and annotation completeness with single-copy orthologs, Bioinformatics, Volume 31, Issue 19, 1 October 2015, Pages 3210–3212, https://doi.org/10.1093/bioinformatics/btv351

3. Hailin Liu, Shigang Wu, Alun Li, Jue Ruan, SMARTdenovo: a de novo assembler using long noisy reads, Gigabyte, 2021  https://doi.org/10.46471/gigabyte.15
