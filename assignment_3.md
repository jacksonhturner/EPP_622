# Assignment 3: Which Assember is better (Flye or SmartDeNovo)?

The objective of this assignment is to compare two assemblers, Flye and SmartDeNovo, using a set of nanopore dogwood chromosome 4 reads as an input. Different assemblers work better for different data, so it's important to review them before performing high-throughput assemblies. 

At the end, I also provide some feedback about the most recent AgBioData video.

## Step 1: Loading in Data 

First, create a directory to deposit the raw data.
```
mkdir 1_raw_data
cd 1_raw_data
```

Load in your data for this assignment by creating a soft link to the nanopore dogwood chromosome 4 reads. The path for these reads exists within the pickett_shared directory within this class's raw data. 

```
ln -s /pickett_shared/teaching/EPP622_Fall2022/raw_data/citrus_test2/microcitrus_australasica_nanopore.4.fastq .
```

In fastq files, four lines correspond to one read. The number of raw reads can be found simply by calculating the number of lines in the fastq file and dividing them by four. 

Generate the number of lines within the fastq file for these reads.
```
wc -l microcitrus_australasica_nanopore.4.fastq
```
This command reveals that there are 1,014,600 lines within this file. Dividing this number by four reveals that there are **253,650 raw reads** in this sample. That's quite a lot!

Generally, it's good practice to use LongQC at this stage of analysis to determine the quality of your long reads. However, because the nanopore_lq.py script on the server doesn't work for these reads, I will not be performing it in this assignment.

## Step 2: Perform Assembly With Flye

Create a new directory and navigate to it.
```
cd ..
mkdir 2_flye_assembly
cd 2_flye_assembly
```

This step utilizes Flye, a long-read assembly algorithm that builds repeat graphs using arbitrary, unknown repeat graphs [1]. Because this assembly algorithm is not native to the server, it will need to be installed. Since flye can be found in bioconda, it will be easiest to install using conda.

Install flye by creating a new conda environment and using bioconda to install the Flye package.
```
conda create -n flye
conda activate flye
conda install -c bioconda flye
```

Now that Flye is installed, double check the version number. 

```
conda list flye
```

Due to some quirk of my personal miniconda3, the following commands installed Flye version 2.8.1.

Next, perform the assembly using Flye, referencing its github (https://github.com/fenderglass/Flye) for whatever specifications needed for the data. Because I've installed Flye version 2.8.1, the assembler automatically scaffolds the assembly without a flag. This command lists using 10 threads, but use however many is appropriate for your computational needs and availability. This will take a few minutes, so feel free to run this in screen. Otherwise, now might be a good oportunity to make yourself some hot tea or do something else to enjoy yourself :)

```
flye --nano-raw microcitrus_australasica_nanopore.4.fastq --out-dir flye_assembly --threads 10
conda deactivate
```

The completed assembly can be found within the flye_assembly directory generated by the previous command. The completed assembly object is ```assembly.fasta``` which will be referenced by future commands.

Once the assembly is finished, it is important to calculate statistics of its contigs and scaffolds that can diagnose its quality. Characteristics like scaffold/contig total, N50, L50, and max length can be used to compare assemblies to, in the case of this assignment, determine the best assembler for a given set of reads. BBMap's stats.sh script will be used to generate these statistics.

Find sequencing statistics of Flye's assembly with BBMap and view them with less.

```
cd flye_assembly
/sphinx_local/software/bbmap/stats.sh -Xmx20g in=flye_assembly/assembly.fasta > assembly_stats.txt
less assembly_stats.txt
```
This file displays the following output. These results will be discussed at the end of this document to compare the Flye assembly with the SmartDeNovo assembly for this assignment.

```
Main genome scaffold total:             639
Main genome contig total:               644
Main genome scaffold sequence total:    35.366 MB
Main genome contig sequence total:      35.365 MB       0.001% gap
Main genome scaffold N/L50:             24/271.267 KB
Main genome contig N/L50:               26/270.297 KB
Main genome scaffold N/L90:             201/23.652 KB
Main genome contig N/L90:               206/23.615 KB
Max scaffold length:                    3.337 MB
Max contig length:                      3.337 MB
Number of scaffolds > 50 KB:            129
% main genome in scaffolds > 50 KB:     83.10%
```

## Step 3: Running BUSCO for the Flye Assembly

BUSCO [2] is a software package designed to create human readable metrics used to evaluate assemblies using single-copy genes. Using it alongside BBMap will allow for a more comprehensive comparison of asseblies than either could provide alone. Let's do it!

Create a directory for BUSCO and navigate to it.

```
cd ../../
mkdir 3_flye_busco
cd 3_flye_busco
```

BUSCO, like Flye, can be downloaded via conda. The following command will create a new environment for BUSCO while installing it at the same time.

```
conda create -n busco -c conda-forge -c bioconda busco=5.3.2
conda activate busco
```

Now that a conda environment has been created and activated for BUCSO, it should be run to provide more information for each assembly. The -m flag describes what time of assembly to analyze, -c determines the number of cores dedicated to this job, and -l describes the type of database of orthologs to reference when analyzing each read. Embryophyta is our database of choice, as it contains orthologs of plants.

Run BUSCO, navigate to the directory it creates, and view the output with less.

```
busco -i ../2_flye_assembly/flye_assembly/assembly.fasta -m genome -l embryophyta -c 2 --out flye_assembly.BUSCO
conda deactivate
cd flye_assembly.BUSCO
less short_summary.specific.embryophyta_odb10.flye_assembly.BUSCO.txt
```

The following output is displayed in the .txt file generated by BUSCO. The values within are specific to BUSCO and can be compared with other BUSCO runs of different assemblies to evaluate their quality. Like the statistics created with BBMap, these results will be discussed at the end of this document.

        --------------------------------------------------
        |Results from dataset embryophyta_odb10           |
        --------------------------------------------------
        |C:10.0%[S:9.3%,D:0.7%],F:1.4%,M:88.6%,n:1614     |
        |161    Complete BUSCOs (C)                       |
        |150    Complete and single-copy BUSCOs (S)       |
        |11     Complete and duplicated BUSCOs (D)        |
        |23     Fragmented BUSCOs (F)                     |
        |1430   Missing BUSCOs (M)                        |
        |1614   Total BUSCO groups searched               |
        --------------------------------------------------

## Step 4: Generate SmartDeNovo Assembly

SmartDeNovo [3] is an assembler for long reads like Flye, but it's designed to work well with raw reads that aren't that great. Time to put it to the test!

Create a new directory for SmartDeNovo and navigate to it.

```
cd ../..
mkdir 4_smartdenovo_assembly
cd 4_smartdenovo_assembly
```

The perl script needed to run SmartDeNovo is already on the server, yay! Using it is also straightforward, with the somewhat necessary flag being the number of cores used. Otherwise, there are no other arguments needed to run it.

Run SmartDeNovo on our data.

```
/pickett_shared/software/smartdenovo/smartdenovo.pl -c 5 ../1_raw_data/microcitrus_australasica_nanopore.4.fastq > microcitrus_australasica.fasta
```

The assembly file generated by SmartDeNovo is ```microcitrus_australasica.dmo.cns``` which will be used to generate statistics used to compare it with Flye's assembly.

Next, run BBMap to obtain some assembly statistics like for Flye and view them with less.

```
/sphinx_local/software/bbmap/stats.sh -Xmx20g in=microcitrus_australasica.dmo.cns > microcitrus_australasica_stats.txt
less microcitrus_australasica_stats.txt
```

Like for Flye, this stats file for SmartDeNovo's assembly contains sequence statistics used to compare it with Flye's assembly. More on this at the end.

```
Main genome scaffold total:             149
Main genome contig total:               149
Main genome scaffold sequence total:    27.007 MB
Main genome contig sequence total:      27.007 MB       0.000% gap
Main genome scaffold N/L50:             10/461.296 KB
Main genome contig N/L50:               10/461.296 KB
Main genome scaffold N/L90:             78/59.325 KB
Main genome contig N/L90:               78/59.325 KB
Max scaffold length:                    2.459 MB
Max contig length:                      2.459 MB
Number of scaffolds > 50 KB:            96
% main genome in scaffolds > 50 KB:     93.62%
```

## Step 5: Running BUSCO for the SmartDeNovo Assembly

Create a new directory for BUSCO and navigate to it. Then, run BUSCO on the SmartDeNovo assembly like for Flye and view the file with less.

```
cd ..
mkdir 5_smartdenovo_busco
cd 5_smartdenovo_busco
conda activate busco
busco -i ../4_smartdenovo_assembly/microcitrus_australasica.dmo.cns -m genome -l embryophyta -c 2 --out SDN_assembly.BUSCO
conda deactivate
cd SDN_assembly.BUSCO
less short_summary.specific.embryophyta_odb10.SDN_assembly.BUSCO.txt
```
The following statistics were generated by BUSCO for SmartDeNovo's assembly.

        --------------------------------------------------
        |Results from dataset embryophyta_odb10           |
        --------------------------------------------------
        |C:9.5%[S:9.3%,D:0.2%],F:1.0%,M:89.5%,n:1614      |
        |154    Complete BUSCOs (C)                       |
        |150    Complete and single-copy BUSCOs (S)       |
        |4      Complete and duplicated BUSCOs (D)        |
        |16     Fragmented BUSCOs (F)                     |
        |1444   Missing BUSCOs (M)                        |
        |1614   Total BUSCO groups searched               |
        --------------------------------------------------
        
## Step 6: Comparing Assemblies

The BBMap metrics provide a large amount of information, so let's dive in!

The number of scaffolds and contigs more or less describe the amount of contiguous reads, with contigs being fully contiguous reads and scaffolds containing gaps between otherwise connected reads. Generally, having less of these is best for assemblies, and SmartDeNovo's assembly has much less than Flye's. The scaffold and contig sequence totals describe how many bases are present in each assembly -- more bases means more information. Flye's assembly has more than SmartDeNovo's, making it a larger assembly. 
The scaffold/contig N50 values (strangely, to the right of the slash of the BBMap statistics instead of the left) describe, if a random contig were to be selected, 50% of the time it would be X or greater. The N50 values of the SmartDeNovo assembly are larger than those of Flye's, meaning it has larger contigs. The L50s describe the count of the smallest number of contigs whose length sum makes up half the genome size. Because SmartDeNovo's L50s are less than Flye's, its contig sizes are larger.
Despite the theme of Flye being more fragmented than SmartDeNovo's assembly, it has a larger maximum contig size. While Flye's assembly features a larger number of contigs and scaffolds greater than 50 KB than SmartDeNovo's, a lesser percentage of its main genome in scaffolds is larger than 50KB than SmartDeNovo's.


The BUSCO statistics generally describe completeness of an assembly, measured in the number of Benchmarking Universal Single-Copy Orthologs (BUSCOs).

According to BUSCO, the Flye assemby is more complete because it has slightly more complete BUSCOs and less missing BUSCOs than the SmartDeNovo assembly. However, the Flye assembly has more fragmented and complete/duplicated and fragmented BUSCOs. Referencing our output from BBMap, this comparison of BUSCO values makes sense because there are more overall bases present in the Flye assembly than in the SmartDeNovo assembly but also many more gaps. 

Ultimately, the choice of best assembler will depend on how one would want to analyze an assembly. **Flye's assembly contains more information (including slightly more complete BUSCOs) but is also much more fragmented, while SmartDeNovo's is probably a better assembly by conventional standards, but contains somewhat less information.** 

## Feedback for AgBioData Video

I don't know much about the standards for this presentation, but the PowerPoint presented in this video seems a little basic. While it's serviceable as a vehicle for the ideas of the presentation, it seems more like a draft than a finished product. There are some grammar errors in the PowerPoint itself and strange skips in the recording that, while nitpicky to point out, subtract from the presentation. The section describing IPA in the standard format and controlled vocabularies file could be explained a little better -- I was unsure if it referred to one nucleotide base or a combination of several. I think adding the part about other stakeholders benefitting from FAIR principles is a smart idea! 

Overall, I think this AgBioData video is a strong complement to the first lesson, and it clearly outlines the FAIR principles!

## References

1. Kolmogorov, M., Yuan, J., Lin, Y. et al. Assembly of long, error-prone reads using repeat graphs. Nat Biotechnol 37, 540–546 (2019). https://doi.org/10.1038/s41587-019-0072-8

2. Felipe A. Simão, Robert M. Waterhouse, Panagiotis Ioannidis, Evgenia V. Kriventseva, Evgeny M. Zdobnov, BUSCO: assessing genome assembly and annotation completeness with single-copy orthologs, Bioinformatics, Volume 31, Issue 19, 1 October 2015, Pages 3210–3212, https://doi.org/10.1093/bioinformatics/btv351

3. Hailin Liu, Shigang Wu, Alun Li, Jue Ruan, SMARTdenovo: a de novo assembler using long noisy reads, Gigabyte, 2021  https://doi.org/10.46471/gigabyte.15
